package main

var Time float
var Origin vec2
var Size vec2
var Progress float

func Fragment(position vec4, texCoord vec2, color vec4) vec4 {
	// 1. Setup UVs (Centered [-1, 1])
	uv := (position.xy - Origin) / (Size * 0.5)

	// 2. Rotate 45 degrees (Diagonal Top-Left to Bottom-Right)
	// We rotate the coordinate system so the diagonal becomes the horizontal (X) axis.
	// Angle = -45 degrees (-0.785 rad) aligns TL->BR to X-axis.
	theta := -0.785
	c := cos(theta)
	s := sin(theta)
	rotUV := vec2(uv.x*c - uv.y*s, uv.x*s + uv.y*c)

	// rotUV.x is now distance along the diagonal.
	// rotUV.y is now distance perpendicular to the diagonal (width).

	// 3. Motion Logic
	// The slash travels from Left to Right in rotated space (TL to BR in screen space).
	// Map Progress (0..1) to a wide X range (-2.0 .. 2.0) to ensure it clears the area.
	centerPos := (Progress * 4.0) - 2.0

	// 'distAlong' is the distance behind the "head" of the slash.
	// Positive values mean we are in the trail. Negative values are ahead of the slash.
	distAlong := centerPos - rotUV.x

	// 4. Shape Definition
	// Tail length determines how long the slash is.
	tailLen := 1.5

	// Cut off anything too far ahead (-0.1) or too far behind (tailLen)
	if distAlong < -0.1 || distAlong > tailLen {
		return vec4(0)
	}

	// Longitudinal Profile (Along the beam)
	// Normalized position t: 0.0 at the head, 1.0 at the tail tip.
	t := distAlong / tailLen

	// Sharp rise at the head (0.0), smooth fade to the tail (1.0).
	headSharpness := smoothstep(-0.1, 0.0, distAlong)
	tailFade := 1.0 - smoothstep(0.5, 1.0, t) // Fade out the last half of the tail

	// Intensity profile along the length
	longIntensity := headSharpness * tailFade

	// 5. Transverse Profile (Width of the beam)
	// Base thickness of the slash
	width := 0.04
	
	// Taper the width at the very tip of the tail
	currentWidth := width * (1.0 - smoothstep(0.8, 1.0, t))

	distPerp := abs(rotUV.y)

	// Core: Very sharp, bright center
	core := 1.0 - smoothstep(0.0, currentWidth, distPerp)

	// Glow: Soft, wider aura
	glowWidth := currentWidth * 8.0
	glow := 1.0 - smoothstep(0.0, glowWidth, distPerp)

	// 6. Coloring
	// Electric Cyan Palette
	colCore := vec3(1.0, 1.0, 1.0)   // White
	colGlow := vec3(0.0, 0.9, 1.0)   // Bright Cyan
	colEdge := vec3(0.0, 0.2, 0.8)   // Deep Blue

	// Mix colors based on radial distance (Core -> Glow -> Edge)
	finalColor := mix(colEdge, colGlow, glow) // Base glow
	finalColor = mix(finalColor, colCore, core) // Add white core

	// 7. Alpha Composition
	// Combine longitudinal intensity with transverse shape
	shapeAlpha := core + (glow * 0.6)
	alpha := longIntensity * shapeAlpha

	// Boost alpha slightly to make it "hot"
	alpha = clamp(alpha * 1.5, 0.0, 1.0)

	// Premultiply alpha for standard blending
	return vec4(finalColor * alpha, alpha) * color
}
//kage:unit pixels

package main

var Time float
var Origin vec2
var Size vec2
var Alpha float

// Hash function for pseudo-random numbers
func hash(p vec2) float {
	return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)
}

// Value Noise: Smooth interpolation between random values on a grid
func noise(p vec2) float {
	i := floor(p)
	f := fract(p)

	// Cubic Hermite Interpolation (smoothstep)
	f = f * f * (3.0 - 2.0 * f)

	// Bilinear interpolation of the hash values
	return mix(mix(hash(i + vec2(0.0, 0.0)), hash(i + vec2(1.0, 0.0)), f.x),
		mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y)
}

// Fractal Brownian Motion: Layering noise at different frequencies
func fbm(p vec2) float {
	v := 0.0
	a := 0.5
	// Rotate to reduce artifacts (optional, but simple shift helps)
	shift := vec2(100.0)
	for i := 0; i < 6; i++ { // Increased iterations for more detail
		v += a * noise(p)
		p = p * 2.0 + shift
		a *= 0.5
	}
	return v
}

func Fragment(dstPos vec4, srcPos vec2, color vec4) vec4 {
	// Normalized UV coordinates (0.0 to 1.0)
	uv := (dstPos.xy - Origin) / Size

	// Circular Mask: Soften edges so it looks like a contained cloud
	d := distance(uv, vec2(0.5))
	// Perturb the inner radius of the mask for a more organic shape
	// Using a separate FBM for mask perturbation
	mask := 1.0 - smoothstep(0.2 + fbm(uv*4.0)*0.1, 0.5, d) 
    
	// Optimization: If outside mask, return transparent
	if mask <= 0.01 {
		return vec4(0)
	}

	// --- Domain Warping for Fluid/Smoke look ---
	
	// Scale UVs for noise frequency, slightly higher for more detail
	p := uv * 4.0 
	
	// 1. First layer of warp
	q := vec2(0.0)
	q.x = fbm(p + vec2(0.0, 0.0))
	q.y = fbm(p + vec2(5.2, 1.3))

	// 2. Second layer of warp (Animated)
	r := vec2(0.0)
	r.x = fbm(p + 4.0*q + vec2(Time*0.4, Time*0.3))
	r.y = fbm(p + 4.0*q + vec2(Time*0.2, Time*0.5))

	// 3. Final Density sampling
	f := fbm(p + 4.0*r)

	// Refine Density: Increase contrast and apply mask
	// Square 'f' to make thin parts thinner and dense parts denser
	// Reduced multiplier for a slightly more ethereal fog look
	density := f * f * f * mask * 1.2
	density = clamp(density, 0.0, 1.0)

	// Color Grading
	// Shifted towards lighter, more "foggy" tones
	colShadow := vec3(0.3, 0.3, 0.35)   // Medium-Dark Blue-Grey
	colHighlight := vec3(0.9, 0.9, 0.95) // Near-White
	
	// Mix color based on the unmasked noise value 'f' (gives variation inside the cloud)
	smokeColor := mix(colShadow, colHighlight, clamp(f*1.5, 0.0, 1.0))

	// Final Alpha combines the calculated density and the global fade Alpha
	finalAlpha := density * Alpha

	// Return premultiplied alpha color (standard for Ebiten)
	return vec4(smokeColor * finalAlpha, finalAlpha)
}